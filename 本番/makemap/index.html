<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>じもすご - 地元ですごろく</title>
  <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css" />
  <script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
  <script src="../lib/TileLayer.GeoJSON.js"></script>
  <script src="../lib/turf.min.js"></script>
  <script src="../lib/dijkstra/graph.js"></script>
  <style>
    body {
      padding: 0;
      margin: 0;
    }

    html,
    body,
    #mapdiv {
      height: 90%;
      width: 95%;
    }

    #mapdiv {
      margin: 5%;
    }

    .leaflet-container {
      background: #fff;
    }

    .gsi-div-icon {
      background: none;
      white-space: nowrap;
      border: none;
    }
  </style>
</head>

<body>
  <select id="mapsize">
    <option value="3">2~4マス デバッグ用</option>
    <option value="8">6~10マス すぐ終わる</option>
    <option value="15">10~20マス 普通</option>
    <option value="100">100マスぐらい 飽きるぐらい長い</option>
  </select>
  <select id="playernum">
    <option value="1">1人プレイ</option>
    <option value="2">2人プレイ</option>
    <option value="3">3人プレイ</option>
    <option value="4">4人プレイ</option>
  </select>
  <!-- mapdiv内に地図が入ってます。 -->
  <!-- ここの余白やら配置やらををいい感じに調整して下さい。 -->
  <div id="mapdiv"> </div>
  <button onclick="playgame()">このマップを遊ぶ！</button>

  <script>

    //道路中心線の両端nodeに付けるid
    var nodeid = 0;
    //道路中心線の両端座標にidを付けて取っておく
    var nodes = {
      type: "FeatureCollection",
      features: []
    };

    var setNode = function (lng, lat) {
      var id;
      var node = turf.filter(nodes, "latlng", lat + "-" + lng);

      if (node.features.length) {
        id = node.features[0].properties.id;
      } else {
        id = nodeid++;
        var newnode = {
          type: "Feature",
          properties: {
            id: id,
            latlng: lat + "-" + lng
          },
          geometry: {
            type: "Point",
            coordinates: [lng, lat]
          }
        };
        nodes.features.push(newnode);
      }
      return id;
    };

    //経路探索用テーブル
    var dijkstramap = {};
    var dijkstrafeature = {};

    var setDijkstraMap = function (sid, eid, length, feature) {
      if (!(sid in dijkstramap)) {
        dijkstramap[sid] = {};
        dijkstrafeature[sid] = {};
      }
      dijkstramap[sid][eid] = length;
      dijkstrafeature[sid][eid] = feature;
    };

    //マーカー移動後の経路探索
    var markerDragEnd = function (e) {
      //前回の結果を消去
      shortestpathlayer.clearLayers();
      gamemaplayer.clearLayers();

      //マーカー近傍のnodeを探索
      var start = turf.nearest(startlayer.getLayers()[0].toGeoJSON(), nodes);
      var end = turf.nearest(goallayer.getLayers()[0].toGeoJSON(), nodes);

      //経路探索
      var graph = new Graph(dijkstramap);
      var shortestpath = graph.findShortestPath(start.properties.id, end.properties.id);

      //探索結果から経路作成
      var f = null;
      var pathlength = 0;
      var spath = [];
      for (var i = 0; i < shortestpath.length - 1; i++) {
        if (shortestpath[i] in dijkstrafeature) {
          if (shortestpath[i + 1] in dijkstrafeature[shortestpath[i]]) {
            f = dijkstrafeature[shortestpath[i]][shortestpath[i + 1]];
            shortestpathlayer.addData(f);
            pathlength += turf.lineDistance(f, "kilometers");
            spath.push(f);
          }
        }
        if (shortestpath[i + 1] in dijkstrafeature) {
          if (shortestpath[i] in dijkstrafeature[shortestpath[i + 1]]) {
            f = dijkstrafeature[shortestpath[i + 1]][shortestpath[i]];
            shortestpathlayer.addData(f);
            spath.push(f);
            pathlength += turf.lineDistance(f, "kilometers");
          }
        }
      }
      var mapsize = Number(document.getElementById("mapsize").value);
      var dist = pathlength / (mapsize + 1);
      var now = 0;
      var spacenum = 0;
      for (var i = 0; i < spath.length; i++) {
        now += turf.lineDistance(spath[i]);
        if (now >= dist) {
          gamemaplayer.addData({
            type: "Feature",
            geometry: { "type": "Point", "coordinates": spath[i].geometry.coordinates[0] },
            properties: {}
          })
          spacenum++;
          now = 0;
        }
      }
    };

    //経路探索結果レイヤ
    var shortestpathlayer = L.geoJson(null, { style: function () { return { "color": "#ff0000", "weight": 5 }; }, clickable: false });

    //道路中心線レイヤ
    var rdcllayer = new L.TileLayer.GeoJSON(
      'http://cyberjapandata.gsi.go.jp/xyz/experimental_rdcl/{z}/{x}/{y}.geojson',
      { minZoom: 16, maxNativeZoom: 16, maxZoom: 18 },
      {
        style: function () {
          return { "color": "#0000ff", "weight": 0 };
        },
        onEachFeature: function (feature, layer) {
          //経路探索時の重みとして経路長さを使用
          var length = turf.lineDistance(feature, "kilometers");

          //経路両端にidを付けて取っておく
          var latlng = feature.geometry.coordinates;
          feature.properties.sid = setNode(latlng[0][0], latlng[0][1]);
          feature.properties.eid = setNode(latlng[latlng.length - 1][0], latlng[latlng.length - 1][1]);

          //経路探索用のテーブルへ保存
          setDijkstraMap(feature.properties.sid, feature.properties.eid, length, feature);
          setDijkstraMap(feature.properties.eid, feature.properties.sid, length, feature);
        }
      }
    );

    //地理院地図レイヤ
    var pale = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', {
      attribution: "地理院タイル", maxZoom: 18, opacity: 1
    });

    //始点、終点マーカーレイヤ
    var startlayer = L.geoJson({
      type: "FeatureCollection",
      features: [{
        type: "Feature",
        geometry: { "type": "Point", "coordinates": [142.368805, 43.771179] },
        properties: {}
      }]
    }, {
      pointToLayer: function (feature, latlng) {
        return L.marker(latlng, {
          icon: L.icon({
            iconUrl: "../images/points/start.png",
            iconSize: [40, 40],
            iconAnchor: [20, 20]
          })
        });
      },
      onEachFeature: function (feature, layer) {
        layer.options.draggable = true;
        layer.on('dragend', function (e) { markerDragEnd(e); });
      }
    });

    var goallayer = L.geoJson({
      type: "FeatureCollection",
      features: [{
        type: "Feature",
        geometry: { "type": "Point", "coordinates": [142.368905, 43.771279] },
        properties: {}
      }]
    }, {
      pointToLayer: function (feature, latlng) {
        return L.marker(latlng, {
          icon: L.icon({
            iconUrl: "../images/points/goal.png",
            iconSize: [40, 40],
            iconAnchor: [20, 20]
          })
        });
      },
      onEachFeature: function (feature, layer) {
        layer.options.draggable = true;
        layer.on('dragend', function (e) { markerDragEnd(e); });
      }
    });

    var gamemaplayer = L.geoJson({
      type: "FeatureCollection",
      features: []
    }, {
      pointToLayer: function (feature, latlng) {
        return L.marker(latlng, {
          icon: L.icon({
            iconUrl: "../images/points/point.png",
            iconSize: [40, 40],
            iconAnchor: [20, 20]
          })
        });
      }
    });

    var map = L.map("mapdiv", {
      center: [43.771179, 142.368805], zoom: 16, minZoom: 8, maxZoom: 18,
      layers: [pale, rdcllayer, startlayer, goallayer, gamemaplayer, shortestpathlayer]
    });

    map.on('zoomend', function (e) {
      if (map.getZoom() < 16) {
        if (map.hasLayer(rdcllayer)) {
          shortestpathlayer.clearLayers();
          startlayer.clearLayers();
          goallayer.clearLayers();
          gamemaplayer.clearLayers();
          map.removeLayer(rdcllayer);
        }
      } else {
        if (!map.hasLayer(rdcllayer)) {
          let c = map.getCenter();
          console.log(c);
          startlayer.addData({
            type: "Feature",
            geometry: { "type": "Point", "coordinates": [c.lng, c.lat] },
            properties: {}
          }
          );
          goallayer.addData({
            type: "Feature",
            geometry: { "type": "Point", "coordinates": [c.lng + 0.001, c.lat] },
            properties: {}
          });
          rdcllayer.addTo(map);
        }
      }
    });

    function playgame() {
      let mapdata = {};
      let s = startlayer.getLayers()[0].toGeoJSON().geometry.coordinates;
      mapdata.start = s;
      let g = goallayer.getLayers()[0].toGeoJSON().geometry.coordinates;
      mapdata.goal = g;
      let points = gamemaplayer.getLayers();
      mapdata.mapsize = points.length;
      let pointCoodinates = []
      points.forEach(i => {
        pointCoodinates.push(i.toGeoJSON().geometry.coordinates);
      });
      mapdata.map = pointCoodinates;
      mapdata.playernum = Number(document.getElementById("playernum").value);
      let url = "../playgame/index.html?mapdata=" + JSON.stringify(mapdata);
      location.href = url;
    }
  </script>
</body>

</html>